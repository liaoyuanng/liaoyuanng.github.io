<!DOCTYPE html>
<html>
<head><!-- post -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading List - Stay True</title>
    <meta name="author"  content="Ju Liaoyuan">
    <meta name="description" content="Reading List">
    <meta name="keywords"  content="Reading">
    <!-- Open Graph -->
    <meta property="og:title" content="Reading List - Stay True">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/2017/05/28/readingList.html">
    <meta property="og:description" content="iOS 搬砖，业余天文爱好者">
    <meta property="og:site_name" content="Stay True">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_roc50gemkxpw4s4i.css">
    <link rel="stylesheet" href= "/assets/css/github-markdown.css" | prepend: site.baseurl >
    <link rel="stylesheet" href="/assets/css/styles/default.css" | prepend: site.baseurl>
    <link rel="stylesheet" href= "/assets/css/share.min.css"  | prepend: site.baseurl>
    <link rel="stylesheet" href= "/assets/css/app.min.css" | prepend: site.baseurl >

    <!-- Favicon -->
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
</head>
<body>
    <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
<input id="nm-switch" type="hidden" value="false">

<header class="g-header">
    <div class="g-logo">
        <a href="/"></a>
    </div>
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">tags</a></li>
            
        </ul>
    </nav>
</header>

<header class="g-banner post-header post-pattern-circuitBoard bgcolor-default " data-theme="default">
    <div class="post-wrapper">
        <div class="post-tags">
             
            
            <a href="/tags#Reading" class="post-tag">Reading</a>
            
            
        </div>
        <h1>Reading List</h1>
        <div class="post-meta">
            <span class="post-meta-item"><i class="iconfont icon-author"></i><a href="http://localhost:4000" target="_blank" rel="author">Leo</a></></span>
            <time class="post-meta-item" datetime="17-05-28"><i class="iconfont icon-date"></i>28 May 2017</time>
        </div>
    </div>
    
    <div class="filter"></div>
    <div class="post-cover" style="background: url('https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/aaron-burden-236415.jpg') center no-repeat; background-size: cover;">
    
</header>

<div class="post-content">
    
    <article class="markdown-body">
        <blockquote>
  <p>TALK IS CHEAP</p>
</blockquote>

<h2 id="asyncdisplaykit-介绍一原理和思路">AsyncDisplayKit 介绍（一）原理和思路</h2>

<p><a href="https://juejin.im/post/58bea6ca570c3500622e0ca9">查看原文</a></p>

<p>暂未使用到这个库。</p>

<h2 id="auto-layout-performance-on-ios">Auto Layout Performance on iOS</h2>

<p><a href="http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/">查看原文</a></p>

<p><strong>关于 <code class="highlighter-rouge">Auto Layout</code> 性能分析的文章</strong></p>

<ul>
  <li>
    <p>显式约束(Explicit constraints)</p>

    <p>使用<code class="highlighter-rouge">NSLayoutConstraint</code>,设置<code class="highlighter-rouge">width</code>、<code class="highlighter-rouge">height</code>、<code class="highlighter-rouge">center</code>、<code class="highlighter-rouge">aligment</code>…来约束视图</p>
  </li>
  <li>
    <p>隐式约束(Implicit constraints)</p>

    <p>对视图设置<code class="highlighter-rouge">content hugging priority</code>和<code class="highlighter-rouge"> compression resistance priority</code>属性</p>
  </li>
  <li>约束的本质: Each constraint is basically just a simple linear equation(每个约束都是一个基本的简单的线性方程).</li>
  <li>
    <p>性能低下(相比设置<code class="highlighter-rouge">Frame</code>而言)的原因:</p>

    <p><code class="highlighter-rouge">约束的本质</code>提到:每个约束都是一个基本的简单的线性方程。所有的约束一起定义了一个明确描述布局的方程组。那么， 把这些<code class="highlighter-rouge">constraint</code>转化为<code class="highlighter-rouge">Frame</code>，其实是线性方程求解的过程，必定是需要消耗一定的系统的性能的。</p>
  </li>
  <li>嵌套视图的性能要低于平行层级视图。</li>
</ul>

<h2 id="并发编程api-及挑战">并发编程：API 及挑战</h2>

<p><a href="https://objccn.io/issue-2-1/">查看原文</a></p>

<ul>
  <li><code class="highlighter-rouge">GCD</code>在后端管理着一个线程池。<code class="highlighter-rouge">GCD</code>不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</li>
  <li>操作队列（operation queue）是由<code class="highlighter-rouge">GCD</code>提供的一个队列模型的<code class="highlighter-rouge">Cocoa</code>抽象.</li>
  <li>资源共享: 并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等.</li>
</ul>

<h4 id="优先级反转">优先级反转</h4>

<p>当我们有一个高优先级的任务(称为<code class="highlighter-rouge">H</code>),一个中优先级的任务(称为<code class="highlighter-rouge">M</code>)和一个低优先级的任务(称为<code class="highlighter-rouge">L</code>), 其中，<code class="highlighter-rouge">H</code> 和 <code class="highlighter-rouge">L</code> 共享一个资源, 而 <code class="highlighter-rouge">M</code> 不需要这个共享资源。</p>

<p>首先，当<code class="highlighter-rouge">L</code>获取共享资源的锁时，正常情况下，<code class="highlighter-rouge">L</code>完成后释放锁，<code class="highlighter-rouge">H</code>就可以正常访问该共享资源。但是如果在<code class="highlighter-rouge">L</code>执行中的时候，突然来了个<code class="highlighter-rouge">M</code>(不需要这个共享资源)，<code class="highlighter-rouge">M</code>就有可能会抢占<code class="highlighter-rouge">L</code>而先被执行。那么由于<code class="highlighter-rouge">L</code>被中断，不能及时释放锁，那么<code class="highlighter-rouge">H</code>也会一直等待锁的释放。这就完成了一个<code class="highlighter-rouge">优先级反转</code></p>

<h2 id="designing-for-ios-graphics-performance">Designing for iOS: Graphics Performance</h2>

<p><a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance#the-case-of-uibutton">查看原文</a></p>

<p>一场关于<code class="highlighter-rouge">iOS</code>绘图性能的讨论。</p>

<h2 id="ios-各个框架的联系">iOS 各个框架的联系</h2>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/tumblr_mdyk43n5jr1qatp4h.png" alt="relation" /></p>

<h2 id="离屏渲染">离屏渲染</h2>
<p>触发离屏渲染的几种情况:</p>

<ol>
  <li>Core Graphics (任何以<code class="highlighter-rouge">CG</code>开头的类) *</li>
  <li>重写<code class="highlighter-rouge">drawRect</code> 方法，即使是空的实现</li>
  <li>设置<code class="highlighter-rouge">CALayer</code>的<code class="highlighter-rouge">shouldRasterize</code> 属性为<code class="highlighter-rouge">YES</code></li>
  <li>设置<code class="highlighter-rouge">maskToBounds</code>和<code class="highlighter-rouge">shadow</code></li>
  <li>任何文本的显示，包括<code class="highlighter-rouge">CoreText</code></li>
  <li>Group opacity</li>
</ol>

<h2 id="关于-gcd--和-nsoperation-的讨论">关于 GCD  和 NSOperation 的讨论</h2>

<p><a href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch">查看原文</a></p>

<ul>
  <li>
    <p>GCD:</p>

    <p><code class="highlighter-rouge">GCD</code>的效率更高，由于<code class="highlighter-rouge">NSOperation</code>是苹果对<code class="highlighter-rouge">GCD</code>的面向对象的封装，那么<code class="highlighter-rouge">NSOperation</code>的创建和销毁就会占用一定的资源。 <code class="highlighter-rouge">GCD</code> 是基于<code class="highlighter-rouge">Block</code> 的，所以书写起来很方便、简洁。我们用很少的代码就可以实现强大的多线程操作。</p>
  </li>
  <li>
    <p>NSOperation:</p>

    <p><code class="highlighter-rouge">NSOperation</code>是对<code class="highlighter-rouge">GCD</code> 的面向对象的封装，有友好的<code class="highlighter-rouge">API</code>，它不是<code class="highlighter-rouge">GCD</code> 的简易版。相反，它实现了许多复杂的功能，比如:设置并发量(bandwidth-constrained queues),这个用<code class="highlighter-rouge">GCD</code>实现起来很难，如果使用<code class="highlighter-rouge">NSOperation</code>就可以让苹果把这件事做了，我们使用起来会很方便。</p>
  </li>
</ul>

<h2 id="about-dispatch-queues">About Dispatch Queues</h2>

<p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">查看原文</a></p>

<ul>
  <li>A dispatch queue is an object-like structure / 每个<code class="highlighter-rouge">dispatch queue</code>都是一个对象类型的结构。</li>
  <li>dispatch queues are first-in, first-out data structures / <code class="highlighter-rouge">dispatch queue</code> 是一个<code class="highlighter-rouge">FIFO</code> 的数据结构。</li>
  <li>Concurrent queues (also known as a type of global dispatch queue) execute one or more tasks concurrently, but tasks are still started in the order in which they were added to the queue / 并发队列可以同时执行一个或者多个任务，但是任务依然是按照添加的顺序启动。(感觉这样翻译更好：任务在队列的顺序还是按照添加时的顺序，只是具体先执行哪个是不可预知的)</li>
  <li>对于<code class="highlighter-rouge">并发任务</code>，指的是队列中的任务，是同时执行的。</li>
</ul>

<h2 id="底层并发-api">底层并发 API</h2>

<p><a href="https://objccn.io/issue-2-3/#multiple_readers_single_writer">查看原文</a></p>

<ul>
  <li>
    <p>dispatch_barrier_async
  <code class="highlighter-rouge">dispatch_barrier_async</code>会等待队列中在它之前的添加的所有任务完成后，再去执行它后面的任务，类似一个栅栏，所以叫做<code class="highlighter-rouge">barrier</code>.</p>
  </li>
  <li>dispatch_apply
    <ul>
      <li>
        <p><code class="highlighter-rouge">dispatch_apply</code> 是同步队列。它会在追加到它队列的所有任务执行完之后，再去处理它下面的代码。因为是同步队列，所以不能指定它的队列是主队列。原因同下面的代码一样:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  dispatch_sync(dispatch_get_main_queue(), ^{
      // Error
  });
        
</code></pre></div>        </div>
      </li>
      <li>
        <p>在<code class="highlighter-rouge">diaatch_apply</code> 里面去打印了当前是否是主线程，发现每四次循环中，第一次是主线程，其余都是子线程，不知道是怎么回事。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>dispatch_benchmark</p>

    <p>** 可以用来测量给定代码执行的时间 **</p>

    <p>在使用的时候要注意，因为这个是<code class="highlighter-rouge">GCD</code>未公开的<code class="highlighter-rouge">API</code>，所以需要声明，在头文件中声明:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  uint64_t dispatch_benchmark(size_t count, void (^block)(void));
</code></pre></div>    </div>
  </li>
  <li>
    <p>自旋锁
  自旋锁跟互斥锁类似，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。在获取锁的时候，如果自旋锁已经被别的执行单元获取，那么调用者就一直循环在那，等待该锁的释放，故名为<code class="highlighter-rouge">自旋</code>。但是自旋锁和互斥锁不一样的是，自旋锁是<code class="highlighter-rouge">busy-waiting</code>,而互斥锁是<code class="highlighter-rouge">sleep-waiting</code>。自旋锁不会引起调用者睡眠，所以效率远高于互斥锁，但随之而来的也有问题：</p>

    <ul>
      <li>死锁。试图递归地获取自旋锁势必会引起死锁。</li>
      <li>一直占用 CPU。如果获取锁的时间很短，则没有影响，但如果获取锁的时间很长，那么将会大大的降低 CPU 的效率。</li>
    </ul>
  </li>
</ul>

<h2 id="线程安全类的设计">线程安全类的设计</h2>

<p><a href="https://objccn.io/issue-2-4/">查看原文</a></p>

<ul>
  <li>
    <p>在主线程之外操作 UI
  根据时机和行为，会产生不同的结果，但是都是不好的结果，可能我们在子线程中给 image 赋值、改变一个 view 的背景颜色，你会发现这种改变通常要过一会才生效。也有可能操作其他属性，直接造成了程序 crash。</p>
  </li>
  <li>OC 中的类其实就是 C 语言中的结构体。</li>
  <li>
    <p>属性的原子性(Atomic)
  参考<code class="highlighter-rouge">runtime</code>的<code class="highlighter-rouge">setter</code> 方法源码：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   
  static inline void reallySetProperty(id self, SEL _cmd, id newValue, 
  ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) 
{
  id oldValue;
  id *slot = (id*) ((char*)self + offset);

  if (copy) {
      newValue = [newValue copyWithZone:NULL];
  } else if (mutableCopy) {
      newValue = [newValue mutableCopyWithZone:NULL];
  } else {
      if (*slot == newValue) return;
      newValue = objc_retain(newValue);
  }

  if (!atomic) {
      oldValue = *slot;
      *slot = newValue;
  } else {
      spin_lock_t *slotlock = &amp;PropertyLocks[GOODHASH(slot)];
      _spin_lock(slotlock);
      oldValue = *slot;
      *slot = newValue;        
      _spin_unlock(slotlock);
  }

  objc_release(oldValue);
}
    
</code></pre></div>    </div>
    <p>可以看到，除了对内存管理的关键字处理外，还对<code class="highlighter-rouge">atomic</code>的处理：如果是<code class="highlighter-rouge">nonatomic</code>，那么仅仅是简单的赋值。如果是<code class="highlighter-rouge">atomic</code>的话，<code class="highlighter-rouge">runtime</code> 会使用<code class="highlighter-rouge">自旋锁</code>来对资源加锁，这也解释了什么<code class="highlighter-rouge">atomic</code> 会比<code class="highlighter-rouge">nonatomic</code> 的效率低。但是，为什么<code class="highlighter-rouge">atomic</code> 还是不能保证线程安全呢？明明<code class="highlighter-rouge">自旋锁</code>是可以达到目的的。</p>
  </li>
</ul>

<h2 id="动画解释">动画解释</h2>

<p><a href="https://objccn.io/issue-12-1/">查看原文</a></p>
<ul>
  <li>
    <p>CA( Core Animation )维护了两个平行的<code class="highlighter-rouge">layer</code>层次结构:<code class="highlighter-rouge">presentation layer tree 表示层树</code> 和 <code class="highlighter-rouge"><span class="k">model</span> <span class="n">layer</span> <span class="n">tree</span> <span class="err">模型层树</span></code>.</p>

    <ul>
      <li>presentation layer:
  <br />
        <blockquote>
          <p>provides a close approximation of the layer that is currently being displayed onscreen. While an animation is in progress, you can retrieve this object and use it to get the current values for those animations. – <a href="https://developer.apple.com/reference/quartzcore/calayer/1410744-presentationlayer">Apple Document</a></p>
        </blockquote>
      </li>
      <li>model layer: 反映了我们能直接看到的 layers 的状态.</li>
      <li>
        <p>我们创建的动画对象，在被添加到<code class="highlighter-rouge">layer</code> 的时候就已经被复制了，也就是说下面的代码对动画的执行效果没有效果：</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  [self.animationView.layer addAnimation:animation forKey:@"position"];
        
  // fillMode 只对 animationView2 起作用。
  animation.fillMode = kCAFillModeForwards;
  [self.animationView2.layer addAnimation:animation forKey:@"position"];
        
</code></pre></div>        </div>
      </li>
      <li>一个 Bug : 当我把三个动画添加到一个动画组里面的时候，发现动画不能被执行，但是没个动画都是可以单独的被执行。在<a href="http://stackoverflow.com/questions/30791741/cagroupanimation-does-not-show-animations-animations-work-fine-when-added-separ">这里</a>找到了答案。但是还是不清楚具体的原因。</li>
    </ul>
  </li>
</ul>

<h2 id="自定义-viewcontroller-容器转场">自定义 ViewController 容器转场</h2>

<p><a href="https://objccn.io/issue-12-3/">查看原文</a></p>

<ul>
  <li>
    <p>对于 Push</p>

    <p>我们需要遵守<code class="highlighter-rouge">UINavigationControllerDelegate</code>的协议，并实现:</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
  - navigationController: animationControllerForOperation: fromViewController: toViewController:
     
</code></pre></div>    </div>
  </li>
  <li>
    <p>对于 Present</p>

    <p>我们需要遵守<code class="highlighter-rouge">UIViewControllerTransitioningDelegate</code>协议，并实现:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
  - animationControllerForPresentedController: presentingController: sourceController:`
    
</code></pre></div>    </div>
  </li>
  <li>
    <p>无论是<code class="highlighter-rouge">Push</code>还是<code class="highlighter-rouge">Present</code>，我们都需要提供我们自定义的转场动画。</p>
  </li>
</ul>


    </article>
    
    <div class="social-share-wrapper">
        <div class="social-share"></div>
    </div>
    
</div>

<section class="author-detail">
    <section class="post-footer-item author-card">
        <div class="avatar">
            <img src="/assets/img/profile.png" alt="">
        </div>
        <div class="author-name" rel="author">Ju Liaoyuan</div>
        <div class="bio">
            <p>iOS 搬砖，业余天文爱好者</p>
        </div>
        
        <ul class="sns-links">
            
            <li>
                <a href="//weibo.com/u/2738809475" target="_blank">
                    <i class="iconfont icon-weibo"></i>
                </a>
            </li>
            
            <li>
                <a href="//juejin.im/user/5872f9822f301e0057490c89" target="_blank">
                    <i class="iconfont icon-juejin"></i>
                </a>
            </li>
            
            <li>
                <a href="//github.com/liaoyuanng" target="_blank">
                    <i class="iconfont icon-github"></i>
                </a>
            </li>
            
            <li>
                <a href="//jianshu.com/u/f386d4a61d33" target="_blank">
                    <i class="iconfont icon-jianshu"></i>
                </a>
            </li>
            
            <li>
                <a href="mailto:liaoyuan@imliaoyuan.com" target="_blank">
                    <i class="iconfont icon-email"></i>
                </a>
            </li>
            
        </ul>
        
    </section>
    <section class="post-footer-item read-next">
        
        <div class="read-next-item">
            <a href="/2017/06/09/What's-new-in-Xcode-9.html" class="read-next-link"></a>
            <section>
                <span>What's new in Xcode 9</span>
                <p>前言</p>
            </section>
            
            <div class="filter"></div>
            <img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/xcode-9-simulator-large.png" alt="">
            
        </div>
        
         
        <div class="read-next-item">
            <a href="/2017/04/16/LYSheetController-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95.html" class="read-next-link"></a>
            <section>
                <span>一个简单易用的弹出菜单</span>
                <p>LYSheetController - 一个简单易用的弹出菜单</p>
            </section>
            
        </div>
        
    </section>
    
</section>

<footer class="g-footer">
    <section>Stay True © 2018</section>
    <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/liaoyuanng/StayTrue">Theme StayTrue</a>
    <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></section>
</footer>

<script src="/assets/js/social-share.min.js"></script>
<script>
    socialShare('.social-share', {
        sites: ['wechat','weibo','twitter','facebook'],
        wechatQrcodeTitle: "分享到微信朋友圈",
        wechatQrcodeHelper: '<p>扫码后分享😘</p>'
    });
</script>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
/*写入自己的disqus信息*/
s.src = '';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
<script src="/assets/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/assets/js/index.min.js"></script>
</body>
</html>