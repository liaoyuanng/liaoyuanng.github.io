<!DOCTYPE html>
<html>
<head><!-- post -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>读《图解 HTTP》笔记 - Stay True</title>
    <meta name="author"  content="Ju Liaoyuan">
    <meta name="description" content="读《图解 HTTP》笔记">
    <meta name="keywords"  content="读书">
    <!-- Open Graph -->
    <meta property="og:title" content="读《图解 HTTP》笔记 - Stay True">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/2018/01/11/noteforhttp.html">
    <meta property="og:description" content="iOS 搬砖，业余天文爱好者">
    <meta property="og:site_name" content="Stay True">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_roc50gemkxpw4s4i.css">
    <link rel="stylesheet" href= "/assets/css/github-markdown.css" | prepend: site.baseurl >
    <link rel="stylesheet" href="/assets/css/styles/default.css" | prepend: site.baseurl>
    <link rel="stylesheet" href= "/assets/css/share.min.css"  | prepend: site.baseurl>
    <link rel="stylesheet" href= "/assets/css/app.min.css" | prepend: site.baseurl >

    <!-- Favicon -->
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
</head>
<body>
    <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
<input id="nm-switch" type="hidden" value="false">

<header class="g-header">
    <div class="g-logo">
        <a href="/"></a>
    </div>
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">tags</a></li>
            
        </ul>
    </nav>
</header>

<header class="g-banner post-header post-pattern-circuitBoard bgcolor-default " data-theme="default">
    <div class="post-wrapper">
        <div class="post-tags">
             
            
            <a href="/tags#读书" class="post-tag">读书</a>
            
            
        </div>
        <h1>读《图解 HTTP》笔记</h1>
        <div class="post-meta">
            <span class="post-meta-item"><i class="iconfont icon-author"></i><a href="http://localhost:4000" target="_blank" rel="author">Ju Liaoyuan</a></></span>
            <time class="post-meta-item" datetime="18-01-11"><i class="iconfont icon-date"></i>11 Jan 2018</time>
        </div>
    </div>
    
    <div class="filter"></div>
    <div class="post-cover" style="background: url('https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/http.png') center no-repeat; background-size: cover;">
    
</header>

<div class="post-content">
    
    <article class="markdown-body">
        <!--more-->

<h2 id="一些常见名词解释">一些常见名词解释</h2>

<p>ARP协议(<code class="highlighter-rouge">Address Resolution Protocol</code>)，即地址解析协议。是根据<code class="highlighter-rouge">IP</code>地址获取物理地址(MAC)。</p>

<p>DNS协议(<code class="highlighter-rouge">Domain Name Server</code>)，是根据<code class="highlighter-rouge">域名</code>来转换与之相应的<code class="highlighter-rouge">IP</code>地址服务器。</p>

<h2 id="tcpip">TCP/IP</h2>

<p><code class="highlighter-rouge">TCP/IP</code>是一个协议簇，在它之上，包含了众多协议。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156883179446.jpg" alt="" /></p>

<p><code class="highlighter-rouge">TCP</code>位于传输层，提供可靠的字节流(注意这里的描述<strong>字节流</strong>,所以 TCP 是流，而不是包)服务。为了准确无误的将数据送达目标，<code class="highlighter-rouge">TCP</code>协议采用三次握手(three-way handshaking) 策略:</p>

<ol>
  <li>首先，发送端发送一个带 SYN 标志的数据包给接收端。</li>
  <li>接收到收到后，回传一个带有 SYN/ACK 的数据包</li>
  <li>发送端再回传一个带 ACK 标志的数据包。握手结束。</li>
</ol>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15149932337872.jpg" alt="" /></p>

<p>HTTP请求示意图</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153084818984.jpg" alt="" /></p>

<h2 id="url-和-uri">URL 和 URI</h2>

<p><code class="highlighter-rouge">URL</code>表示资源的地点(互联网上所处的位置)。<code class="highlighter-rouge">URI</code> 表示字符串标识某一互联网资源。<code class="highlighter-rouge">URL</code>是<code class="highlighter-rouge">URI</code>的子集。<code class="highlighter-rouge">URI</code>表示互联网上某个资源，它包含<code class="highlighter-rouge">URL</code>和<code class="highlighter-rouge">URN</code>(统一资源名称)，而<code class="highlighter-rouge">URL</code>则表示这个资源具体的位置。比如张三有一台 MAC 电脑，李四也有一台 MAC 电脑，这都是<code class="highlighter-rouge">URI</code>，但是，怎么区分呢，继续拿这个举例子，比如张三在河南郑州，那么可以简单表示为:<code class="highlighter-rouge">地址：河南/郑州/张三/MAC</code>，而李四在上海，表示为<code class="highlighter-rouge">地址：上海/静安/李四/MAC</code>，这就是<code class="highlighter-rouge">URL</code>。因为现在<code class="highlighter-rouge">URN</code>已经很少见了，所以现在基本上见到的既是<code class="highlighter-rouge">URI</code>也是<code class="highlighter-rouge">URL</code>。</p>

<h2 id="请求和响应">请求和响应</h2>

<p>HTTP 协议规定：请求从<code class="highlighter-rouge">客户端</code>发出，<code class="highlighter-rouge">服务器</code>端回复响应。</p>

<h3 id="http-报文">HTTP 报文</h3>

<p>用于 HTTP 协议交互的信息称为 HTTP 报文。请求端的是请求报文，响应端的是响应报文。报文大致可分为报文首部和报文主体两块，两者之间通常用空行(<code class="highlighter-rouge">CRLF</code>)来划分。报文主体不是必须的。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153183891618.jpg" alt="" /></p>

<p>请求报文实例：</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153188871970.jpg" alt="" /></p>

<p>响应报文实例</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153189070154.jpg" alt="" /></p>

<h3 id="请求">请求</h3>

<p>请求报文是由<code class="highlighter-rouge">请求方法</code>、<code class="highlighter-rouge">请求URI</code>、<code class="highlighter-rouge">协议版本</code>、<code class="highlighter-rouge">可选的请求首部字段</code>和<code class="highlighter-rouge">内容实体</code>构成的。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153061515839.jpg" alt="" /></p>

<p>请求方法有下面几种：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">方法</th>
      <th style="text-align: center">说明</th>
      <th style="text-align: center">协议版本</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">GET</td>
      <td style="text-align: center">获取资源</td>
      <td style="text-align: center">1.0、1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">POST</td>
      <td style="text-align: center">传输实体主体</td>
      <td style="text-align: center">1.0、1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">PUT</td>
      <td style="text-align: center">传输文件</td>
      <td style="text-align: center">1.0、1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">HEAD</td>
      <td style="text-align: center">获取报文首部</td>
      <td style="text-align: center">1.0、1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">DELETE</td>
      <td style="text-align: center">删除文件</td>
      <td style="text-align: center">1.0、1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">OPTIONS</td>
      <td style="text-align: center">询问支持的方法</td>
      <td style="text-align: center">1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">TRACE</td>
      <td style="text-align: center">追踪路径</td>
      <td style="text-align: center">1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">CONNECT</td>
      <td style="text-align: center">要求用隧道协议连接代理</td>
      <td style="text-align: center">1.1</td>
    </tr>
    <tr>
      <td style="text-align: center">LINK(已废弃)</td>
      <td style="text-align: center">建立和资源之间的联系</td>
      <td style="text-align: center">1.0</td>
    </tr>
    <tr>
      <td style="text-align: center">UNLINK(已废弃)</td>
      <td style="text-align: center">断开连接关系</td>
      <td style="text-align: center">1.0</td>
    </tr>
  </tbody>
</table>

<p>其中，<code class="highlighter-rouge">HEAD</code>方法是获得报文首部，和<code class="highlighter-rouge">GET</code>方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间(比如确认一个缓存是否过期)等。<code class="highlighter-rouge">PUT</code>和<code class="highlighter-rouge">DELETE</code>方法由于不带验证机制，所以一般不使用。<code class="highlighter-rouge">OPTIONS</code>方法用查询针对请求<code class="highlighter-rouge">URI</code>指定资源支持的方法。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153071237018.jpg" alt="" /></p>

<p><code class="highlighter-rouge">TRACE</code>方法用来追踪请求经过的转发，在<code class="highlighter-rouge">Max-Forwards</code>首部字段中填入数值，每经过一个服务器端就将该数字减一，当数值刚好减到0时，就停止继续传输。这个方法不常用，而且容易被<code class="highlighter-rouge">XST（跨站追踪）</code>攻击。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153078439847.jpg" alt="" /></p>

<p><code class="highlighter-rouge">CONNECT</code>方法要求在与代理服务器通信时，建立隧道，实现用隧道协议进行<code class="highlighter-rouge">TCP</code>通信。主要使用<code class="highlighter-rouge">SSL</code>和<code class="highlighter-rouge">TLS</code>一些把通信内容加密后经网络隧道传输。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153080039011.jpg" alt="" /></p>

<h3 id="响应">响应</h3>

<p>响应报文基本上由<code class="highlighter-rouge">协议版本</code>、<code class="highlighter-rouge">状态码</code>（表示请求成功或失败的数字代码）、<code class="highlighter-rouge">用以解释状态码的原因短语</code>、<code class="highlighter-rouge">可选的响应首部字段</code>以及<code class="highlighter-rouge">实体主体</code>构成.</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153065402666.jpg" alt="" /></p>

<h3 id="请求中的持久连接">请求中的<span id="connection">持久连接</span></h3>

<p>在 HTTP 协议的初始版本中，每一次 HTTP 通信都要断开一次 TCP 连接，因为之前都是很小的文本传输, 所以也没有什么问题，但慢慢的，图片的需求越来越多，在一个<code class="highlighter-rouge">HTML</code>页面可能有多张图片，而这些图片（资源）需要单独的请求获取，就造成了没有必要的 TCP 的建立和断开。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153089067780.jpg" alt="" /></p>

<p>为了解决这个问题，就出现了<code class="highlighter-rouge">持久连接(HTTP keep-alive)</code>的方法。只要任意一端没有明确提出断开连接，就会继续保持<code class="highlighter-rouge">TCP</code>连接状态。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153090084089.jpg" alt="" /></p>

<p>在<code class="highlighter-rouge">HTTP/1.1</code>中持久连接已经是默认行为。</p>

<h3 id="cookie">Cookie</h3>

<p>由于<strong>HTTP是无状态协议</strong>，它不对之前发生过的请求和响应进行管理，无法根据之前的状态进行本次的请求处理。比如一个电商页面，用户登录后，然后进行购买，但是这个时候服务器端并不知道他已经登录了，需要附加额外的参数来管理登录状态。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153141156009.jpg" alt="" /></p>

<p>为了解决这个问题，所以引入了<code class="highlighter-rouge">Cookie</code>技术。</p>

<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>

<ol>
  <li>客户端第一次请求，这个时候没有<code class="highlighter-rouge">Cookie</code>信息。</li>
  <li>服务器端发送的响应报文内增加一个<code class="highlighter-rouge">Set-Cookie</code>的首部字段信息，告知客户端保存<code class="highlighter-rouge">Cookie</code>。</li>
  <li>客户端再次请求的时候，客户端会自动在报文中加入<code class="highlighter-rouge">Cookie</code>值发送出去。</li>
  <li>这样，服务器端就能够知道这个客户端之前的状态。</li>
</ol>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153144988830.jpg" alt="" /></p>

<h3 id="范围请求range-requeset">范围请求(Range Requeset)</h3>

<p>在下载中，如果遇到了网络中断的情况，就必须从头开始，大大影响了效率。为了解决这个问题，就产生了一种可恢复的机制，让下载可以在中断处恢复下载，即<code class="highlighter-rouge">断点续传</code>。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153857888012.jpg" alt="" /></p>

<p>我们使用首部字段<code class="highlighter-rouge">Range</code>来指定资源的 Byte 范围。</p>

<ul>
  <li>5001 ~ 10000字节：<code class="highlighter-rouge">Range:bytes = 5001-10000</code></li>
  <li>5001字节之后全部的：<code class="highlighter-rouge">Range:bytes = 5001-</code></li>
  <li>多重范围，0-3000，5000-7000：<code class="highlighter-rouge">Range:bytes = -3000, 5000-7000</code></li>
</ul>

<h3 id="http-首部字段">HTTP 首部字段</h3>

<p>HTTP 首部字段是构成 HTTP 报文的要素之一。它分为四种：</p>

<ul>
  <li>通用首部字段: 请求报文和响应报文两方都会使用的首部。</li>
  <li>请求首部字段: 客户端发送请求报文时使用的首部。</li>
  <li>响应首部字段: 服务器端返回响应报文时使用的首部。</li>
  <li>实体首部字段: 针对请求报文和响应报文的实体部分使用的首部。</li>
</ul>

<p>下面是部分字段解释。</p>

<h4 id="通用首部字段">通用首部字段</h4>

<ol>
  <li>
    <p>Cache-Control</p>

    <p><code class="highlighter-rouge">Cache-Control</code>控制缓存的行为，指令的参数是可选的，多个指令之间通过<code class="highlighter-rouge">，</code>分割。</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15153996798170.jpg" alt="" /></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Cache-Control: provate，max-age=0，no-cache
</code></pre></div>    </div>

    <p>缓存请求指令一览</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">指令</th>
          <th style="text-align: center">参数</th>
          <th style="text-align: center">说明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">no-cache</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">强制向源服务器再次验证</td>
        </tr>
        <tr>
          <td style="text-align: center">no-store</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">不缓存请求或响应的任何内容</td>
        </tr>
        <tr>
          <td style="text-align: center">max-age=[秒]</td>
          <td style="text-align: center">必须</td>
          <td style="text-align: center">响应的最大 Age 值</td>
        </tr>
        <tr>
          <td style="text-align: center">max-stale(=[秒])</td>
          <td style="text-align: center">可省略</td>
          <td style="text-align: center">接收已过期的响应</td>
        </tr>
        <tr>
          <td style="text-align: center">min-fresh=[秒]</td>
          <td style="text-align: center">必须</td>
          <td style="text-align: center">期望在指定时间内的响应仍有效</td>
        </tr>
        <tr>
          <td style="text-align: center">no-transform</td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">代理不更改媒体类型</td>
        </tr>
        <tr>
          <td style="text-align: center">only-if-cached</td>
          <td style="text-align: center">无</td>
          <td style="text-align: center">从缓存获取资源</td>
        </tr>
        <tr>
          <td style="text-align: center">cache-extension</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">新指令标记(token)</td>
        </tr>
      </tbody>
    </table>

    <p>缓存响应指令一览</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">指令</th>
          <th style="text-align: center">参数</th>
          <th style="text-align: center">说明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">public</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">可向任意方提供响应的缓存</td>
        </tr>
        <tr>
          <td style="text-align: center">private</td>
          <td style="text-align: center">可省略</td>
          <td style="text-align: center">仅向特定用户返回响应</td>
        </tr>
        <tr>
          <td style="text-align: center">no-cache</td>
          <td style="text-align: center">可省略</td>
          <td style="text-align: center">缓存前必须先确认其有效性</td>
        </tr>
        <tr>
          <td style="text-align: center">no-store</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">不缓存请求或响应的任何内容</td>
        </tr>
        <tr>
          <td style="text-align: center">no-trnasform</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">代理不可更改媒体类型</td>
        </tr>
        <tr>
          <td style="text-align: center">must-revalidate</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">可缓存但必须向源服务器进行确认</td>
        </tr>
        <tr>
          <td style="text-align: center">proxy-revalidate</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">要求中间缓存服务器对缓存的响应有效性再进行确认</td>
        </tr>
        <tr>
          <td style="text-align: center">max-age=[秒]</td>
          <td style="text-align: center">必须</td>
          <td style="text-align: center">响应的最大 Age 值</td>
        </tr>
        <tr>
          <td style="text-align: center">s-maxage=[秒]</td>
          <td style="text-align: center">必须</td>
          <td style="text-align: center">公共缓存服务器响应的最大 Age 值</td>
        </tr>
        <tr>
          <td style="text-align: center">cache-extension</td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">新指令标记(token)</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>no-cache</li>
    </ul>

    <p>指令的目的为了防止从缓存中返回过期的资源，而不是不缓存。</p>
  </li>
  <li>
    <p>Connection</p>

    <p><code class="highlighter-rouge">Connection</code>字段具有两个作用：</p>

    <ul>
      <li>控制不再转发给代理的首部字段</li>
      <li>管理持久连接</li>
    </ul>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15154011047041.jpg" alt="" /></p>

    <p><code class="highlighter-rouge">HTTP/1.1</code>版本默认连接都是<a href="#connection">持久连接</a>,如果要在之前版本维持持续连接，则设值为<code class="highlighter-rouge">Keep-Alive</code>。客户端会在持久连接上连续发送请求，当服务器端明确要断开连接时，会指定<code class="highlighter-rouge">Connection</code>首部字段的值为Close。</p>
  </li>
  <li>
    <p>Data</p>

    <p><code class="highlighter-rouge">Data</code>表明创建<code class="highlighter-rouge">HTTP</code>报文的日期和时间。日期时间格式为：</p>

    <ul>
      <li>
        <p>HTTP/1.1 RFC1123:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Data: Tue，03 Jul 2012 04:40:40 GMT
</code></pre></div>        </div>
      </li>
      <li>
        <p>HTTP/1.0 RFC850:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Data: Tue，03-Jul-12 02:02:02 GMT
</code></pre></div>        </div>
      </li>
      <li>
        <p>Other</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Data: Tue Jul 02 02:02:02 2018
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h4 id="请求首部字段部分">请求首部字段(部分)</h4>

<blockquote>
  <p>注：下面的”用户代理”指的是客户端</p>
</blockquote>

<p><code class="highlighter-rouge">请求首部字段</code>是从<code class="highlighter-rouge">客户端</code>往<code class="highlighter-rouge">服务器端</code>发送请求报文中所使用的字段，用于补充请求的<code class="highlighter-rouge">附加信息</code>、<code class="highlighter-rouge">客户端信息</code>、<code class="highlighter-rouge">对响应内容相关的优先级</code>等内容。</p>

<ol>
  <li>
    <p>Accept</p>

    <p><code class="highlighter-rouge">Accept</code>首部字段可告知服务器，<em>用户代理</em> 能够处理的媒体类型及媒体类型的相对优先级。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Accept: text/html, application/xhtml+xml,applicaiton/xml;q=0.9,*/*;q=0.8
</code></pre></div>    </div>

    <p>其中，<code class="highlighter-rouge">text/html, application/xhtml+xml,applicaiton/xml</code>属于媒体类型，<code class="highlighter-rouge">*/*</code>表示任意的媒体类型。<code class="highlighter-rouge">q=0.9</code>表示优先级(权重)，<code class="highlighter-rouge">q</code>的值范围是<code class="highlighter-rouge">0~1</code>，如果不指定，默认是<code class="highlighter-rouge">1.0</code>。</p>
  </li>
  <li>
    <p>Accept-Charset</p>

    <p>用来告知服务器用户代理支持的字符集及相对优先顺序。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Accept-Charset: iso-8859-5,unicode-1-1;q=0.8
</code></pre></div>    </div>
  </li>
  <li>
    <p>Accept-Encoding</p>

    <p>用来告知服务器用户代理支持的<code class="highlighter-rouge">内容编码格式</code>及<code class="highlighter-rouge">优先顺序</code>。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Accept-Encoding:gzip,deflate
</code></pre></div>    </div>
    <p>编码格式有：</p>

    <ul>
      <li>gzip，由文件压缩程序 gzip 生成的编码格式。</li>
      <li>compress，由 UNIX 文件压缩程序 compress 生成的编码格式。</li>
      <li>deflate，组成使用 zlib 格式及由 deflate 压缩算法生成的编码格式。</li>
      <li>identity，不执行压缩或不会变化的默认编码格式。</li>
    </ul>
  </li>
  <li>
    <p>Accept-Language</p>

    <p>告知服务器用户代理能够处理的自然语言集(zh、en、jp等)及优先级。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
</code></pre></div>    </div>

    <p>如果没有优先级高的对应的响应，就会返回低优先级的响应。</p>
  </li>
  <li>
    <p>Host</p>

    <p>告知服务器，请求的资源所处的互联网主机名和端口号。<strong>这个字段是唯一一个必须被包含在请求内的首部字段</strong></p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15154122645933.jpg" alt="" /></p>
  </li>
  <li>
    <p>If-Match</p>

    <p>附带条件请求，形如<code class="highlighter-rouge">If-xxx</code>这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15154124507946.jpg" alt="" /></p>
  </li>
  <li>
    <p>Referer</p>

    <p>告知服务器，请求的原始资源的<code class="highlighter-rouge">URI</code>.</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15155527531865.jpg" alt="" /></p>
  </li>
  <li>
    <p>TE(Accept-Transfer-Encoding)</p>

    <p>告知服务器，客户端能够处理响应的<code class="highlighter-rouge">传输编码方式</code>及<code class="highlighter-rouge">优先级</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> TE: gzip,deflate;q=0.5
</code></pre></div>    </div>
  </li>
  <li>
    <p>User-Agent</p>

    <p>告知服务器，客户端的种类。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1
</code></pre></div>    </div>
  </li>
  <li>
    <p>Authorization</p>

    <p>告知服务器，用户代理的认证信息(证书值)。通常，当客户端收到服务器返回的<code class="highlighter-rouge">401</code>状态码后，就是需要加入<code class="highlighter-rouge">Authorization</code>字段。把账号和密码以<code class="highlighter-rouge">:</code>号分割后，用<code class="highlighter-rouge">Base64</code>编码后发送。格式为：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Authorization: Basic  dWVub3NlbjpwYXNzd29yZA==
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="响应首部字段部分">响应首部字段(部分)</h4>

<p><code class="highlighter-rouge">响应首部字段</code>是由<code class="highlighter-rouge">服务器</code>向<code class="highlighter-rouge">客户端</code>返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15155538481739.jpg" alt="" /></p>

<ol>
  <li>
    <p>Accept-Ranges</p>

    <p>告知客户端，服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。
字段的值有两种：可处理时，指定为<code class="highlighter-rouge">bytes</code>；不能处理时，指定为<code class="highlighter-rouge">none</code>.</p>
  </li>
  <li>
    <p>Age</p>

    <p>告知客户端，源服务器在多久前创建了响应。单位为秒</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15155542983298.jpg" alt="" /></p>
  </li>
  <li>
    <p>ETag</p>

    <p>告知客户端，实体标识。它是一种可将资源以字符串形式做唯一性标识的方法。服务器会为每份资源分配对应的<code class="highlighter-rouge">ETag</code>值，当资源更新时，<code class="highlighter-rouge">ETag</code>值也需要更新。
 <code class="highlighter-rouge">ETag</code>值又分为<code class="highlighter-rouge">强ETag值</code>和<code class="highlighter-rouge">弱ETag值</code> 。</p>

    <ul>
      <li>强ETag值：无论实体发生多么细微的变化都会改变其值</li>
      <li>弱ETag值：只用于标记资源是否相同，只有资源发生了根本改变，产生差异时才会改变<code class="highlighter-rouge">ETag</code>值。这时，会在字段值最开始处附加<code class="highlighter-rouge">W/</code>：<code class="highlighter-rouge">ETag: W/"usagi-1234"</code></li>
    </ul>
  </li>
  <li>
    <p>Location</p>

    <p>可以将响应接收方(客户端)引导至某个与请求URI位置不同的资源。</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15155843491597.jpg" alt="" /></p>

    <p>该字段一般会搭配<code class="highlighter-rouge">code 3xx Redirection</code>使用,提供重定向的<code class="highlighter-rouge">URI</code></p>
  </li>
  <li>
    <p>Retry-After</p>

    <p>告知客户端应该在多久之后再次发送请求，常配合状态码<code class="highlighter-rouge">503 Service Unavailable</code>或<code class="highlighter-rouge">3xx Redirect</code>响应一起使用。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Retry-After:120
 // or
 Retry-After: Wed, 04 Jul 2012 06:34:24
</code></pre></div>    </div>
  </li>
  <li>
    <p>Server</p>

    <p>告知客户端，当前服务器上安装的<code class="highlighter-rouge">HTTP</code>服务器应用程序的信息。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Server:Apache/2.2.17(Unix)
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="实体首部字段部分">实体首部字段(部分)</h4>

<p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用与补充内容的更新时间与实体相关的信息。</p>

<ol>
  <li>
    <p>Allow</p>

    <p>告知客户端，能够支持<code class="highlighter-rouge">Request-URI</code>指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以<code class="highlighter-rouge">405 Method Not Allowed</code>作为响应返回。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Allow: GET,HEAD
</code></pre></div>    </div>
  </li>
  <li>
    <p>Content-Encoding</p>

    <p>告知客户端，服务器对实体的主体部分选用的内容编码方式。主要有 4 种内容编码的方式:<code class="highlighter-rouge">gzip</code>、<code class="highlighter-rouge">compress</code>、<code class="highlighter-rouge">deflate</code>、<code class="highlighter-rouge">identity</code>.</p>
  </li>
  <li>
    <p>Content-Type</p>

    <p>表示报文主体的对象类型。默认是<code class="highlighter-rouge">text/html</code>。</p>

    <p>当报文主体文件有多个且多种文件类型的时候(多见于下载/上传文件)，会指定为<code class="highlighter-rouge">multipart/form-data</code>，HTTP 请求方法是<code class="highlighter-rouge">POST</code>。并且用<code class="highlighter-rouge">boundary</code>来分割多个<code class="highlighter-rouge">Part</code>，<code class="highlighter-rouge">boundary</code>是随机生成的字符串。如<code class="highlighter-rouge">AFNetworking</code>中是这样生成的：</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15178242413315.jpg" alt="" /></p>

    <p>完整的<code class="highlighter-rouge">Content-Type</code>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Content-Type: multipart/form-data; boundary=Boundary+D38FFC1FF8FB864D
</code></pre></div>    </div>

    <p>在各个<code class="highlighter-rouge">Part</code>的起始行之前插入<code class="highlighter-rouge">--</code>标记（如：–Boundary+D38FFC1FF8FB864D），并在最后一部分的结尾插入<code class="highlighter-rouge">--</code>标记（如：–Boundary+D38FFC1FF8FB864D–）。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> --Boundary+D38FFC1FF8FB864D
Content-Disposition: form-data; name="header"; filename="Caches1.jpg"
Content-Type: image/jpeg

 // 这里是数据部分

 --Boundary+D38FFC1FF8FB864D--
</code></pre></div>    </div>
  </li>
  <li>
    <p>Content-Disposition</p>

    <p>用于指示回复的内容以何种形式展示。最初是用在<code class="highlighter-rouge">MIME</code>标准中。它可以用在<code class="highlighter-rouge">main body</code>的<code class="highlighter-rouge">Header</code>或者<code class="highlighter-rouge">multipart body</code>的<code class="highlighter-rouge">Header</code>中。</p>

    <ul>
      <li>
        <p>main body. 在消息主体中，用于指示内容是以内联<code class="highlighter-rouge">inline</code>还是附件<code class="highlighter-rouge">attachment</code>的像是展示。前者是直接在浏览器页面中显示，后者是下载到本地。</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Disposition: inline
Content-Disposition: attachment; filename="filename.jpg"
</code></pre></div>        </div>
      </li>
      <li>
        <p>multipart body. 在<code class="highlighter-rouge">multipart body</code>中，指示每个部分的内容是何种格式。</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Disposition: form-data
Content-Disposition: form-data; name="fieldName"
Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
</code></pre></div>        </div>
        <p>第一个参数总是固定不变的<code class="highlighter-rouge">formdata</code>。</p>
      </li>
    </ul>

    <p><strong>其中，filename参数是预填为下载/上传后的文件名</strong></p>
  </li>
  <li>
    <p>Content-Language</p>

    <p>告知客户端，实体主体使用的自然语言(zh、en、jp…)</p>
  </li>
  <li>
    <p>Content-Length</p>

    <p>表明了实体主体部分的大小，单位字节。</p>
  </li>
</ol>

<h4 id="为cookie服务的首部字段">为Cookie服务的首部字段</h4>

<ul>
  <li>Set-Cookie 开始状态管理所使用的 Cookie 信息，在响应首部字段里。</li>
  <li>Cookie 服务器接收到的 Cookie 信息(由客户端发出)，在请求首部字段里。</li>
</ul>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156532484114.jpg" alt="" /></p>

<ol>
  <li>Set-Cookie 字段属性</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp; secure; httponly
</code></pre></div></div>

<p>属性格式为：<code class="highlighter-rouge">NAME=VALUE</code>。</p>

<ul>
  <li>expires, Cookie 的有效期，若不指定，默认为浏览器关闭前为止。</li>
  <li>path，将服务器上的文件目录作为 Cookie 的适用对象。</li>
  <li>domain，作为 Cookie 适用对象的域名</li>
  <li>Secure，仅在 HTTPS 安全通信时才会发送 Cookie</li>
  <li>HttpOnly，加以限制，使 Cookie 不能被 JavaScript 脚本访问。</li>
</ul>

<h4 id="其他首部字段">其他首部字段</h4>

<ol>
  <li>X-Frame-Options</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X-Frame-Options: DENY
</code></pre></div></div>

<p><code class="highlighter-rouge">X-Frame-Options</code>属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。主要目的是为了防止<a href="https://zh.wikipedia.org/zh-hans/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">点击劫持</a>，这里还有一个例子很好的说明这个问题：<a href="https://www.cnblogs.com/lovesong/p/5248483.html">Web安全之点击劫持(ClickJacking)</a></p>

<h4 id="http-的不足">HTTP 的不足</h4>

<ul>
  <li>通信使用明文，内容可能会被窃听</li>
  <li>不验证通信方的身份，因此有可能遭遇伪装</li>
  <li>无法证明报文的完整性，所以有可能已遭篡改(中间人攻击)</li>
</ul>

<h2 id="https">HTTPS</h2>

<p>HTTPS 就是针对 HTTP 的不足，做出了改善。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156604937937.jpg" alt="" /></p>

<ol>
  <li>
    <p>通信的加密</p>

    <p><code class="highlighter-rouge">HTTPS</code>在<code class="highlighter-rouge">HTTP</code>上加入了<code class="highlighter-rouge">SSL</code>。</p>
  </li>
  <li>
    <p>证书验证</p>

    <p><code class="highlighter-rouge">SSL</code>不仅提供加密处理，而且还使用了一种被称为<code class="highlighter-rouge">证书</code>的手段，可用于确定对方信息。<code class="highlighter-rouge">证书</code>由值得信任的第三方机构颁发。</p>

    <p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156596068342.jpg" alt="" /></p>
  </li>
</ol>

<h3 id="加密方式">加密方式</h3>

<p>HTTPS 采用的是<code class="highlighter-rouge">对称加密</code>和<code class="highlighter-rouge">非对称加密</code>混合的机制。</p>

<h3 id="https-通讯过程">HTTPS 通讯过程</h3>

<p>前面说到，<code class="highlighter-rouge">HTTPS</code>其实就是一个披着<code class="highlighter-rouge">SSL</code>的<code class="highlighter-rouge">HTTP</code>，所以，通讯过程也就是在<code class="highlighter-rouge">HTTP</code>通讯前，先建立<code class="highlighter-rouge">SSL</code>连接。</p>

<ol>
  <li>客户端发送<code class="highlighter-rouge">ClientHello</code>报文，开始<code class="highlighter-rouge">SSL</code>通信，报文中包含客户端支持的<code class="highlighter-rouge">SSL</code>的指定版本、加密组件列表(所使用的加密算法及密钥长度等)</li>
  <li>服务器端会以<code class="highlighter-rouge">ServerHello</code>报文作为应答。同客户端一样，报文中包含<code class="highlighter-rouge">SSL</code>版本以及加密组件，加密组件的内容是从接收的客户端加密组件内筛选出来的。</li>
  <li>服务器端发送<code class="highlighter-rouge">Certificate</code>报文。报文中包含公开密钥证书。</li>
  <li>最后服务器端发送<code class="highlighter-rouge">ServerHelloDone</code>报文，<code class="highlighter-rouge">SSL</code>第一次握手结束。</li>
  <li>客户端发送<code class="highlighter-rouge">ClientKeyExchange</code>报文作为回应。报文中包含通信加密中使用的一种被称为<code class="highlighter-rouge">Pre-master-secret</code>的随机密码串。这里的报文已经用步骤3中的公开密钥进行加密。</li>
  <li>客户端发送<code class="highlighter-rouge">ChangeCipherSpec</code>报文，该报文会提示服务器，在之后的通信会采用<code class="highlighter-rouge">Pre-master secret</code>密钥加密。</li>
  <li>客户端发送<code class="highlighter-rouge">Finished</code>报文。该报文包含连接至今全部报文的整体校验值。握手是否成功，要依服务器是否能够正确解密该报文作为判定标准</li>
  <li>服务器端发送<code class="highlighter-rouge">ChangeCipherSpec</code>报文</li>
  <li>服务器端发送<code class="highlighter-rouge">Finished</code>报文。</li>
  <li>当<code class="highlighter-rouge">Finished</code>报文交换完毕之后，<code class="highlighter-rouge">SSL</code>连接就算建立完成，之后的通信都会受到<code class="highlighter-rouge">SSL</code>的保护。接下来就是<code class="highlighter-rouge">HTTP</code>的请求了。</li>
</ol>

<h3 id="https-速度慢">HTTPS 速度慢</h3>

<p>首先，<code class="highlighter-rouge">HTTPS</code>和<code class="highlighter-rouge">HTTP</code>相比，网络负载可能会变慢2-100倍，<code class="highlighter-rouge">SSL</code>的通信慢，而且<code class="highlighter-rouge">SSL</code>的加密解密也需要耗费大量的 CPU 以及内存资源。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156709170124.jpg" alt="" /></p>

<h3 id="https-的单向认证和双向认证补充">HTTPS 的单向认证和双向认证（补充）</h3>

<p>太长不看版：</p>

<p>单向认证就是仅客户端去认证服务器端的<code class="highlighter-rouge">CA</code>证书是否有效，常见与普通的<code class="highlighter-rouge">HTTPS</code>。双向认证就是一个服务器端<code class="highlighter-rouge">CA</code>证书，多个客户端<code class="highlighter-rouge">CA</code>证书，不仅客户端需要验证服务器端的<code class="highlighter-rouge">CA</code>证书，服务器端也要验证客户端的<code class="highlighter-rouge">CA</code>证书，常见于银行web页面，就是经常需要你下载安装他们的证书。</p>

<h4 id="单向认证">单向认证</h4>

<ol>
  <li>客户端发送<code class="highlighter-rouge">ClientHello</code>报文，开始<code class="highlighter-rouge">SSL</code>通信。</li>
  <li>服务器端将<code class="highlighter-rouge">CA</code>证书、公钥等发送给客户端。</li>
  <li>
    <p>客户端验证<code class="highlighter-rouge">CA</code>证书，成功继续，失败退出。</p>

    <p>… 正常的 SSL 建立过程</p>
  </li>
</ol>

<h4 id="双向认证">双向认证</h4>

<ol>
  <li>客户端发送<code class="highlighter-rouge">ClientHello</code>报文，开始<code class="highlighter-rouge">SSL</code>通信。</li>
  <li>服务器端将<code class="highlighter-rouge">CA</code>证书、公钥等发送给客户端。</li>
  <li>客户端验证<code class="highlighter-rouge">CA</code>证书，成功继续，失败退出。</li>
  <li>客户端将自己的<code class="highlighter-rouge">CA</code>证书、公钥等发送给服务器端。</li>
  <li>
    <p>服务器验证客户端你的证书。成功继续，失败断开。</p>

    <p>… 正常的 SSL 建立过程</p>
  </li>
</ol>

<h2 id="全双工通信-websocket">全双工通信 WebSocket</h2>

<p><code class="highlighter-rouge">WebSocket</code>，即<code class="highlighter-rouge">Web</code>浏览器和<code class="highlighter-rouge">Web</code>服务器之间全双工通信标准，建立在<code class="highlighter-rouge">HTTP</code>协议之上，发起方仍是<code class="highlighter-rouge">客户端</code>。一旦<code class="highlighter-rouge">Web服务器</code>于<code class="highlighter-rouge">客户端</code>之间建立<code class="highlighter-rouge">WebSocket</code>协议的通信连接，之后所有的通信都用这个专用协议进行。通讯过程中可互相发送<code class="highlighter-rouge">JSON</code>、<code class="highlighter-rouge">XML</code>、<code class="highlighter-rouge">HTML</code>或者<code class="highlighter-rouge">图片</code>等任意格式的数据。一旦连接确立，无论是服务器，还是客户端，都可以直接向对方发送报文。</p>

<h3 id="握手">握手</h3>

<p>为了实现<code class="highlighter-rouge">WebSocket</code>通信，在<code class="highlighter-rouge">HTTP</code>连接建立后，需要完成一次握手的步骤。</p>

<h4 id="请求-1">请求</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre></div></div>

<p>其中,<code class="highlighter-rouge">Upgrade</code>首部字段告知服务器要更新的通信协议，如果服务器支持，会返回<code class="highlighter-rouge">101 Switching Protocols</code>响应。</p>

<h4 id="响应-1">响应</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
</code></pre></div></div>

<h4 id="握手结束">握手结束</h4>

<p>成功握手确立<code class="highlighter-rouge">WebSocket</code>连接之后，通信时不在使用<code class="highlighter-rouge">HTTP</code>的数据帧，而是采用<code class="highlighter-rouge">WebSocket</code>独立的数据帧。</p>

<p><img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/15156865516613.jpg" alt="" /></p>

<blockquote>
  <p>文中所有图片均来自<a href="https://www.amazon.cn/dp/B00JTQK1L4/ref=sr_1_1?ie=UTF8&amp;qid=1515687926&amp;sr=8-1&amp;keywords=%E5%9B%BE%E8%A7%A3http">图解 HTTP</a>一书。仅作为阅读笔记，关于更多内容请购买正版查阅。</p>
</blockquote>


    </article>
    
    <div class="social-share-wrapper">
        <div class="social-share"></div>
    </div>
    
</div>

<section class="author-detail">
    <section class="post-footer-item author-card">
        <div class="avatar">
            <img src="/assets/img/profile.png" alt="">
        </div>
        <div class="author-name" rel="author">Ju Liaoyuan</div>
        <div class="bio">
            <p>iOS 搬砖，业余天文爱好者</p>
        </div>
        
        <ul class="sns-links">
            
            <li>
                <a href="//weibo.com/u/2738809475" target="_blank">
                    <i class="iconfont icon-weibo"></i>
                </a>
            </li>
            
            <li>
                <a href="//juejin.im/user/5872f9822f301e0057490c89" target="_blank">
                    <i class="iconfont icon-juejin"></i>
                </a>
            </li>
            
            <li>
                <a href="//github.com/liaoyuanng" target="_blank">
                    <i class="iconfont icon-github"></i>
                </a>
            </li>
            
            <li>
                <a href="//jianshu.com/u/f386d4a61d33" target="_blank">
                    <i class="iconfont icon-jianshu"></i>
                </a>
            </li>
            
            <li>
                <a href="mailto:liaoyuan@imliaoyuan.com" target="_blank">
                    <i class="iconfont icon-email"></i>
                </a>
            </li>
            
        </ul>
        
    </section>
    <section class="post-footer-item read-next">
        
        <div class="read-next-item">
            <a href="/2018/01/17/swift-try.html" class="read-next-link"></a>
            <section>
                <span>Swift - try, try?, try!</span>
                <p></p>
            </section>
            
        </div>
        
         
        <div class="read-next-item">
            <a href="/2018/01/01/free(2017),-malloc(2018).html" class="read-next-link"></a>
            <section>
                <span>free(2017), malloc(2018)</span>
                <p>  第三旋臂边缘的一颗蓝色行星上的碳基生物正在庆祝他们所在的行星又在该恒星系里完成了一次公转</p>
            </section>
            
            <div class="filter"></div>
            <img src="https://leo-1253441258.cos.ap-shanghai.myqcloud.com/blog/dribbble.png" alt="">
            
        </div>
        
    </section>
    
</section>

<footer class="g-footer">
    <section>Stay True © 2018</section>
    <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/liaoyuanng/StayTrue">Theme StayTrue</a>
    <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></section>
</footer>

<script src="/assets/js/social-share.min.js"></script>
<script>
    socialShare('.social-share', {
        sites: ['wechat','weibo','twitter','facebook'],
        wechatQrcodeTitle: "分享到微信朋友圈",
        wechatQrcodeHelper: '<p>扫码后分享😘</p>'
    });
</script>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
/*写入自己的disqus信息*/
s.src = '';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
<script src="/assets/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/assets/js/index.min.js"></script>
</body>
</html>